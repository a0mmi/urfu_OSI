Я нашёл такие ошибки:
(1)* В проверке допустимых операторов вместо символа '/' (slash, 0x2F) стоит обратный слеш \ (0x5C) — поэтому ввод вроде 5/2 считается «Illegal operation».
(2)* В ветвлении вычислений второе сравнение, которое должно проверять - (0x2D), ошибочно снова сравнивает с '+' (0x2B) — из-за этого вычитание не выполняется.
(3)* При выполнении деления перед idiv ebx используется xor edx, edx (обнуляет EDX) вместо cdq — это даёт неправильный результат для отрицательных делимых (и вообще некорректно для знакового деления).
(5)* Нет проверки деления на ноль — программа упадёт с исключением при idiv ebx если ebx==0. (?) -- Считается ли ошибкой отсутствие? Или ошибка -- это про неправильную работу?
(4)* Вычитание идёт в деление

Описание патчей:
1. замена '\' на '/'
Заменяю инструкцию: 'cmp eax, 5Ch' на 'cmp eax, 2Fh'
2. Исправление '+' на '-'
Инструкция: 'cmp ecx, 2Bh' заменяется на 'cmp ecx, 2Dh' — это заменит проверку на '-'
3. Заменить xor edx, edx на cdq — сохраняется размер 2 байта,  выравнивание и не ломается код после.
В hex-view заменил в строчке 32 D2 F7 FB: 32 на 99, D2 на 90
4. У меня такой блок:
loc_325ACC:
mov     eax, [ebp+var_8]
mov     ebx, [ebp+var_14]
movzx   ecx, [ebp+var_29]
cmp     ecx, 2Bh ; '+'
jnz     short 

Заменил "jnz short " на `jnz short <Адрес прыжка до "cmp ecx, '-'">` (`jnz short +0x04`)

5. Добавил проверку ошибки деления на нуль. Нашёл свободное место между 0x00****B68 и 0x00****B8 (code-cave)
!!code-cave: 0x00****B68 (в дампе db 50h dup(0CCh) — ~80 байт свободных 0xCC)!!
.text:00DE5B68 ; ---------------------------------------------------------------------------
.text:00DE5B68 ; START OF FUNCTION CHUNK FOR _main_0
.text:00DE5B68
.text:00DE5B68 loc_DE5B68:                             ; CODE XREF: _main_0:loc_DE5AF2↑j
.text:00DE5B68                 cmp     ebx, 0          ; Trap to Debugger
.text:00DE5B6B                 jz      short loc_DE5B75 ; Trap to Debugger
.text:00DE5B6D                 cdq                     ; Trap to Debugger
.text:00DE5B6E                 idiv    ebx             ; Trap to Debugger
.text:00DE5B70                 jmp     loc_DE5AF6      ; Trap to Debugger
.text:00DE5B75 ; ---------------------------------------------------------------------------
.text:00DE5B75
.text:00DE5B75 loc_DE5B75:                             ; CODE XREF: _main_0+14B↑j           // Переход на ошибку "Illegal operation"
.text:00DE5B75                 jmp     loc_DE5ABB
.text:00DE5B7A ; ---------------------------------------------------------------------------
Добавил такой код выше на адрес 0x00DE5B68. Была проблема в том, что проверка минимум 4 байт, а максимум, что можно было вставить перед делением, -- это 2 байта, поэтому требовалось найти свободное место. (Code-cave)
Я направляю так:
.text:00DE5AE8
.text:00DE5AE8 loc_DE5AE8:                             ; CODE XREF: _main_0+C2↑j
.text:00DE5AE8                 cmp     ecx, 2Ah ; '*'
.text:00DE5AEB                 jnz     short loc_DE5AF2
.text:00DE5AED                 imul    eax, ebx
.text:00DE5AF0                 jmp     short loc_DE5AF6
.text:00DE5AF2 ; ---------------------------------------------------------------------------
.text:00DE5AF2
.text:00DE5AF2 loc_DE5AF2:                             ; CODE XREF: _main_0+CB↑j
.text:00DE5AF2                 jmp     short loc_DE5B68                                     // Тут я перехожу на code-cave -- 2 байта
.text:00DE5AF2 ; ---------------------------------------------------------------------------
.text:00DE5AF4                 db    0                                                      // idvi, ebx -- 2 байта обнулил11
.text:00DE5AF5                 db    0
.text:00DE5AF6 ; ---------------------------------------------------------------------------
А дальше перехожу на продолжение функций.